#include <iostream>
#include <vector>
#include <cmath>

class Vector {
public:
    double x, y, z;
    Vector(double x=0, double y=0, double z=0): x(x), y(y), z(z) {}
    double norm() const { return std::sqrt(x*x + y*y + z*z); }
    Vector normalize() const { return *this / norm(); }
    Vector operator+(const Vector& v) const { return Vector(x+v.x, y+v.y, z+v.z); }
    Vector operator-(const Vector& v) const { return Vector(x-v.x, y-v.y, z-v.z); }
    Vector operator*(double a) const { return Vector(x*a, y*a, z*a); }
    Vector operator/(double a) const { return Vector(x/a, y/a, z/a); }
    double operator*(const Vector& v) const { return x*v.x + y*v.y + z*v.z; }
    Vector operator%(const Vector& v) const { return Vector(y*v.z - z*v.y, z*v.x - x*v.z, x*v.y - y*v.x); }
};

class Ray {
public:
    Vector origin, direction;
    Ray(const Vector& origin, const Vector& direction): origin(origin), direction(direction.normalize()) {}
};

class Object {
public:
    virtual bool intersect(const Ray& ray, double& t) const = 0;
    virtual Vector normal(const Vector& point) const = 0;
    virtual Vector color() const = 0;
};

class Sphere: public Object {
public:
    Vector center, color;
    double radius;
    Sphere(const Vector& center, double radius, const Vector& color): center(center), radius(radius), color(color) {}
    bool intersect(const Ray& ray, double& t) const override {
        Vector oc = ray.origin - center;
        double a = ray.direction * ray.direction;
        double b = 2 * oc * ray.direction;
        double c = oc * oc - radius*radius;
        double discriminant = b*b - 4*a*c;
        if (discriminant < 0) return false;
        t = (-b - std::sqrt(discriminant)) / (2*a);
        if (t < 0) {
            t = (-b + std::sqrt(discriminant)) / (2*a);
            if (t < 0) return false;
        }
        return true;
    }
    Vector normal(const Vector& point) const override {
        return (point - center) / radius;
    }
    Vector color() const override { return color; }
};

class Camera {
public:
    Vector position, lookat, up;
    double fov, aspect_ratio;
    Camera(const Vector& position, const Vector& lookat, const Vector& up, double fov, double aspect_ratio):
        position(position), lookat(lookat), up(up), fov(fov), aspect_ratio(aspect_ratio) {}
    Ray get_ray(double x, double y) const {
        Vector px = (lookat - position) % up;
        Vector py = px % (lookat - position);
        double angle = std::tan(fov/2 * M_PI/180);
        Vector direction = (lookat - position + px*2*x/aspect_ratio*angle + py*2*y*angle).normalize();
        return Ray(position, direction);
    }
};

class Scene {
public:
    std::vector<Object*> objects;
    std::vector<Vector> lights;
    Scene() {}
    void add_object(Object* object) { objects.push_back
