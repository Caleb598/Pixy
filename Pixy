import bpy

# Define the custom panel class
class PIXELATION_PT_Panel(bpy.types.Panel):
    bl_label = "Pixelation"
    bl_idname = "PIXELATION_PT_panel"
    bl_space_type = 'PROPERTIES'
    bl_region_type = 'WINDOW'
    bl_context = "output"

    def draw(self, context):
        layout = self.layout

        # Add panel content here
        layout.label(text="Pixelation Settings")

        # Example: Add an animated property
        scene = context.scene
        layout.prop(scene, "pixel_scale_x")
        layout.prop(scene, "pixel_scale_y")


# Register the panel and properties
def register():
    bpy.utils.register_class(PIXELATION_PT_Panel)
    bpy.types.Scene.pixel_scale_x = bpy.props.FloatProperty(name="Pixel Scale X", default=1.0, min=0.01, max=10.0)
    bpy.types.Scene.pixel_scale_y = bpy.props.FloatProperty(name="Pixel Scale Y", default=1.0, min=0.01, max=10.0)


# Unregister the panel and properties
def unregister():
    bpy.utils.unregister_class(PIXELATION_PT_Panel)
    del bpy.types.Scene.pixel_scale_x
    del bpy.types.Scene.pixel_scale_y


# Run the register() function when executing the script
if __name__ == "__main__":
    register()

    # Set keyframes for animation
    scene = bpy.context.scene
    scene.frame_start = 1
    scene.frame_end = 100
    scene.pixel_scale_x = 1.0
    scene.pixel_scale_y = 1.0

    scene.frame_set(scene.frame_start)
    scene.keyframe_insert(data_path="pixel_scale_x")
    scene.keyframe_insert(data_path="pixel_scale_y")

    scene.frame_set(scene.frame_end)
    scene.pixel_scale_x = 10.0
    scene.pixel_scale_y = 10.0
    scene.keyframe_insert(data_path="pixel_scale_x")
    scene.keyframe_insert(data_path="pixel_scale_y")
import bpy

# Define the custom panel class
class PIXELATION_PT_Panel(bpy.types.Panel):
    bl_label = "Pixelation"
    bl_idname = "PIXELATION_PT_panel"
    bl_space_type = 'PROPERTIES'
    bl_region_type = 'WINDOW'
    bl_context = "output"

    def draw(self, context):
        layout = self.layout

        # Add panel content here
        layout.label(text="Pixelation Settings")

        # Example: Add an animated property with animation dot
        scene = context.scene
        layout.prop(scene, "pixel_scale_x", icon='FCURVE')
        layout.prop(scene, "pixel_scale_y", icon='FCURVE')


# Register the panel and properties
def register():
    bpy.utils.register_class(PIXELATION_PT_Panel)
    bpy.types.Scene.pixel_scale_x = bpy.props.FloatProperty(name="Pixel Scale X", default=1.0, min=0.01, max=10.0)
    bpy.types.Scene.pixel_scale_y = bpy.props.FloatProperty(name="Pixel Scale Y", default=1.0, min=0.01, max=10.0)


# Unregister the panel and properties
def unregister():
    bpy.utils.unregister_class(PIXELATION_PT_Panel)
    del bpy.types.Scene.pixel_scale_x
    del bpy.types.Scene.pixel_scale_y


# Run the register() function when executing the script
if __name__ == "__main__":
    register()
import bpy

# Set the initial resolution percentage
initial_resolution_percentage = 50

# Set the final resolution percentage
final_resolution_percentage = 100

# Set the animation frame range
start_frame = 1
end_frame = 100

# Calculate the resolution increment
resolution_increment = (final_resolution_percentage - initial_resolution_percentage) / (end_frame - start_frame)

# Set the render properties
bpy.context.scene.render.image_settings.file_format = 'PNG'

# Animate the resolution over time
for frame in range(start_frame, end_frame + 1):
    bpy.context.scene.frame_set(frame)

    # Calculate the current resolution percentage
    current_resolution_percentage = initial_resolution_percentage + (resolution_increment * (frame - start_frame))
    current_resolution_percentage = round(current_resolution_percentage)  # Round to nearest integer

    # Set the current resolution percentage
    bpy.context.scene.render.resolution_percentage = current_resolution_percentage

    # Render the frame
    bpy.ops.render.render(write_still=True)

    # Apply pixelation effect in the compositor
    bpy.context.scene.use_nodes = True
    tree = bpy.context.scene.node_tree

    # Clear existing nodes
    for node in tree.nodes:
        tree.nodes.remove(node)

    # Create the necessary nodes
    render_layers_node = tree.nodes.new('CompositorNodeRLayers')
    scale_node = tree.nodes.new('CompositorNodeScale')
    scale_node.space = 'RENDER_SIZE'
    scale_node.inputs[1].default_value = current_resolution_percentage / 100.0
    composite_node = tree.nodes.new('CompositorNodeComposite')

    # Connect the nodes
    tree.links.new(render_layers_node.outputs[0], scale_node.inputs[0])
    tree.links.new(scale_node.outputs[0], composite_node.inputs[0])

    # Render the composited image
    bpy.ops.render.render(write_still=True)

    # Reset the compositor for the next frame
    bpy.context.scene.use_nodes = False
    for node in tree.nodes:
        tree.nodes.remove(node)

import bpy

# Set up the scene and objects
# ... (code for setting up the scene and objects)

# Set up the render settings
bpy.context.scene.render.use_compositing = True
bpy.context.scene.use_nodes = True

# Clear existing nodes
bpy.context.scene.node_tree.nodes.clear()

# Create the Compositor nodes
tree = bpy.context.scene.node_tree
render_layers_node = tree.nodes.new('CompositorNodeRLayers')
composite_node = tree.nodes.new('CompositorNodeComposite')
viewer_node = tree.nodes.new('CompositorNodeViewer')

# Set up the links between nodes
links = tree.links
links.new(render_layers_node.outputs[0], composite_node.inputs[0])
links.new(render_layers_node.outputs[0], viewer_node.inputs[0])

# Set the frame to 1
bpy.context.scene.frame_set(1)

# Animate the resolution
frame_start = 1
frame_end = 100
bpy.context.scene.frame_start = frame_start
bpy.context.scene.frame_end = frame_end

# Set up the pixel size
initial_scale = (1920, 1080)  # Adjust the initial pixel size as desired
final_scale = (1920, 1080)  # Adjust the final pixel size as desired

# Generate the frames with different resolutions
for frame in range(frame_start, frame_end + 1):
    bpy.context.scene.frame_set(frame)
    
    # Set the initial resolution
    bpy.context.scene.render.resolution_x = initial_scale[0]
    bpy.context.scene.render.resolution_y = initial_scale[1]
    
    # Render the frame
    bpy.ops.render.render(write_still=True)
    
    # Set the final resolution for the next frame
    bpy.context.scene.render.resolution_x = final_scale[0]
    bpy.context.scene.render.resolution_y = final_scale[1]
