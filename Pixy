bl_info = {
    "name": "Pixy",
    "author": "Caleb Burnett",
    "version": (1, 0, 0),
    "blender": (2, 80, 0),
    "location": "Render Engine",
    "description": "Render engine that produces a pixelated effect.",
    "category": "Render",
}

import bpy

# Set the initial and final sample counts
initial_samples = 16
final_samples = 256
num_steps = 10

# Calculate the increment for each step
sample_increment = (final_samples - initial_samples) / num_steps

# Render the image with increasing sample counts
for i in range(num_steps):
    # Set the current sample count
    sample_count = int(initial_samples + (i * sample_increment))
    bpy.context.scene.cycles.samples = sample_count
    
    # Render the image
    bpy.ops.render.render(write_still=True)
import bpy
from math import ceil


# Custom Render Engine
class PixelatedRenderEngine(bpy.types.RenderEngine):
    bl_idname = "Pixy"
    bl_label = "Pixy"
    bl_use_preview = True

    def __init__(self):
        super().__init__()
        self.pixelation_factor = 8

    def update(self, data, scene):
        self.pixelation_factor = scene.pixelation_factor

    def render(self, scene):
        width = scene.render.resolution_x
        height = scene.render.resolution_y
        aspect_ratio = width / height
        pixels_x = ceil(width / self.pixelation_factor)
        pixels_y = ceil(height / self.pixelation_factor)

        self.begin_result(0, 0, width, height)
        self.begin_result_pass(0, 0, width, height)

        pixel_size_x = width / pixels_x
        pixel_size_y = height / pixels_y

        for j in range(pixels_y):
            for i in range(pixels_x):
                x = i * pixel_size_x
                y = j * pixel_size_y
                color = self.get_pixel_color(scene, x, y, pixel_size_x, pixel_size_y)
                self.set_pixel((i * self.pixelation_factor), (j * self.pixelation_factor), color)

        self.end_result_pass()
        self.end_result()

    def get_pixel_color(self, scene, x, y, size_x, size_y):
        # Perform custom pixel color calculation here
        # For demonstration purposes, we'll use a simple average color
        pixel_color = [0.0, 0.0, 0.0]

        for j in range(int(size_y)):
            for i in range(int(size_x)):
                r, g, b, _ = scene.view_layers[0].samples[x + i, y + j]
                pixel_color[0] += r
                pixel_color[1] += g
                pixel_color[2] += b

        num_pixels = size_x * size_y
        pixel_color = [c / num_pixels for c in pixel_color]

        return pixel_color


# Panel in Render Properties
class PixelatedRenderPanel(bpy.types.Panel):
    bl_label = "Pixelation"
    bl_idname = "RENDER_PT_pixelation"
    bl_space_type = 'PROPERTIES'
    bl_region_type = 'WINDOW'
    bl_context = "render"

    def draw(self, context):
        layout = self.layout
        scene = context.scene

        layout.prop(scene, "pixelation_factor", text="Pixelation")


# Register Classes
def register():
    bpy.utils.register_class(PixelatedRenderEngine)
    bpy.utils.register_class(PixelatedRenderPanel)
    bpy.types.Scene.pixelation_factor = bpy.props.IntProperty(
        name="Pixelation",
        default=0,
        min=0,
        max=32
    )


# Unregister Classes
def unregister():
    del bpy.types.Scene.pixelation_factor
    bpy.utils.unregister_class(PixelatedRenderPanel)
    bpy.utils.unregister_class(PixelatedRenderEngine)


# Register Add-on
if __name__ == "__main__":
    register()
import bpy

# Render the scene
import bpy

# Loop through all objects in the scene
for obj in bpy.context.scene.objects:
    if obj.type == 'MESH':
        # Check if the object has a material assigned
            # Create a new material
            material = bpy.data.materials.new(name="MyMaterial")
            # Assign the material to the object
            obj.data.materials.append(material)
import bpy

# Create a new material
material = bpy.data.materials.new(name="MyMaterial")

# Assign a color to the material
material.use_nodes = True
material.node_tree.nodes.clear()
output_node = material.node_tree.nodes.new('ShaderNodeOutputMaterial')
diffuse_node = material.node_tree.nodes.new('ShaderNodeBsdfDiffuse')
material.node_tree.links.new(diffuse_node.outputs['BSDF'], output_node.inputs['Surface'])

# Get the active object
obj = bpy.context.active_object

# Assign the material to the object

# Switch to "Rendered" mode for previewing the material
for area in bpy.context.screen.areas:
    if area.type == 'VIEW_3D':
        for space in area.spaces:
            if space.type == 'VIEW_3D':
                space.shading.type = 'MATERIAL'
                break
import bpy
import bgl
import blf

# Define your custom render engine class
class CustomRenderEngine(bpy.types.RenderEngine):
    bl_idname = "Pixy"
    bl_label = "Pixy"

    def __init__(self):
        super().__init__()

    def render(self, scene):
        # Perform rendering calculations and output the result to the viewport or a file
        # You can access scene data, such as objects, materials, and lights using the 'scene' parameter
        
        # Example: Rendering code that outputs a simple red image
        width = scene.render.resolution_x
        height = scene.render.resolution_y
        pixels = [1.0, 0.0, 0.0] * (width * height)  # Red pixels

        # Display the rendered image in the viewport
        self.display_pixels(pixels, width, height)

    def view_update(self, context, depsgraph):
        # Display the rendered image in the Blender viewport
        self.display_pixels(self.pixels, self.width, self.height)

    def display_pixels(self, pixels, width, height):
        # Create an OpenGL texture and display the rendered image in the viewport
        tex_id = bgl.glGenTextures(1)
        bgl.glBindTexture(bgl.GL_TEXTURE_2D, tex_id)
        bgl.glTexImage2D(bgl.GL_TEXTURE_2D, 0, bgl.GL_RGB, width, height, 0, bgl.GL_RGB, bgl.GL_FLOAT, pixels)

        # Rest of the display_pixels implementation remains the same

    def update(self, data, depsgraph):
        # Update any engine-specific data when the scene changes
        pass

    def report(self, report_type, message):
        # Handle reporting of errors, warnings, and other messages
        pass

# Register the custom render engine addon
def register():
    bpy.utils.register_class(CustomRenderEngine)

# Unregister the custom render engine addon
def unregister():
    bpy.utils.unregister_class(CustomRenderEngine)
import bpy

# Create a new material or access an existing material
material = bpy.data.materials.new(name="MyMaterial")

# Clear existing nodes in the material's node tree
material.use_nodes = True
material.node_tree.nodes.clear()

# Create a Principled BSDF node
principled_node = material.node_tree.nodes.new('ShaderNodeBsdfPrincipled')

# Set the base color of the material
principled_node.inputs[0].default_value = (0.8, 0.2, 0.4, 1.0)  # RGBA values

# Create a Subsurface Scattering node
sss_node = material.node_tree.nodes.new('ShaderNodeSubsurfaceScattering')

# Set the radius for subsurface scattering
sss_node.inputs[0].default_value = (0.1, 0.1, 0.1, 0.1)

# Create the Material Output node
output_node = material.node_tree.nodes.new('ShaderNodeOutputMaterial')

# Link the nodes together
material.node_tree.links.new(principled_node.outputs[0], output_node.inputs[0])
material.node_tree.links.new(sss_node.outputs[0], principled_node.inputs[0])

# Assign the material to the selected object

# Update the object and the viewport
bpy.context.view_layer.update()
bpy.ops.wm.redraw_timer(type='DRAW_WIN_SWAP', iterations=1)
import bpy

# Access the active material or create a new one
if material is None:
    material = bpy.data.materials.new(name="MyMaterial")
# Enable the use of nodes and clear existing nodes
material.use_nodes = True
material.node_tree.nodes.clear()
# Create the Subsurface Scattering node
sss_node = material.node_tree.nodes.new('ShaderNodeSubsurfaceScattering')
# Set the radius for subsurface scattering
sss_node.inputs['Radius'].default_value = (0.1, 0.1, 0.1)
# Get the Material Output node
output_node = material.node_tree.nodes.get('Material Output')

# Connect the SSS node to the Material Output node
# Update the material
material.update_tag()

# Update the object and the viewport
bpy.context.view_layer.update()
bpy.ops.wm.redraw_timer(type='DRAW_WIN_SWAP', iterations=1)
import bpy

# Create a new point light
light_data = bpy.data.lights.new(name="PointLight", type='POINT')
light_object = bpy.data.objects.new(name="PointLight", object_data=light_data)

# Set light properties
light_object.location = (0, 0, 3)  # Position of the light
light_data.energy = 100.0  # Intensity of the light

# Link the light to the scene
scene = bpy.context.scene
scene.collection.objects.link(light_object)

# Set the light as the active object
bpy.context.view_layer.objects.active = light_object
light_object.select_set(True)

import bpy

# Create a light object
light_data = bpy.data.lights.new(name="Light", type='POINT')
light_object = bpy.data.objects.new(name="Light", object_data=light_data)
bpy.context.collection.objects.link(light_object)

# Create a material with emissive properties
material = bpy.data.materials.new(name="EmissiveMaterial")
material.use_nodes = True
nodes = material.node_tree.nodes
links = material.node_tree.links

# Clear default nodes
nodes.clear()

# Create an emission node
emission_node = nodes.new(type="ShaderNodeEmission")
emission_node.inputs[0].default_value = (1.0, 1.0, 1.0, 1.0)  # Set emission color
emission_node.inputs[1].default_value = 10.0  # Set emission strength

# Create a material output node
output_node = nodes.new(type="ShaderNodeOutputMaterial")

# Connect the emission node to the output node
links.new(emission_node.outputs[0], output_node.inputs[0])

# Assign the material to the light object

# Set the light object as visible in the Material Preview mode
light_object.show_in_front = True
import bpy

# Create a light object
light_data = bpy.data.lights.new(name="Light", type='POINT')
light_object = bpy.data.objects.new(name="Light", object_data=light_data)
bpy.context.collection.objects.link(light_object)

# Add custom properties to the light object
light_object["Light Intensity"] = 0.0

# Define a property group for the light object properties
class LightObjectProperties(bpy.types.PropertyGroup):
    custom_property_1: bpy.props.FloatProperty(
        name="Light Intensity",
        min=0.0,  # Minimum value
        max=1000.0,  # Maximum value
        default=0.0,
    )

# Register the property group
bpy.utils.register_class(LightObjectProperties)

# Add the property group to the light object
bpy.types.Object.light_object_properties = bpy.props.PointerProperty(type=LightObjectProperties)

# Define a panel to display the custom properties
class LightObjectPropertiesPanel(bpy.types.Panel):
    bl_label = "Light Object Properties"
    bl_idname = "OBJECT_PT_light_object_properties"
    bl_space_type = 'PROPERTIES'
    bl_region_type = 'WINDOW'
    bl_context = "data"
    bl_options = {'DEFAULT_CLOSED'}

    @classmethod
    def poll(cls, context):
        return context.object and context.object.type == 'LIGHT'

    def draw(self, context):
        layout = self.layout
        light_object = context.object

        # Draw the custom properties
        layout.prop(light_object.light_object_properties, "property_1")

# Register the panel
bpy.utils.register_class(LightObjectPropertiesPanel)
import bpy

# Select the object that you want to emit light
obj = bpy.context.object

# Create a new material or use the existing material of the object

# Clear all existing material nodes
material.use_nodes = True
material.node_tree.nodes.clear()

# Add the Emission Shader node
emission_node = material.node_tree.nodes.new(type="ShaderNodeEmission")

# Set the emission color and strength
emission_node.inputs["Color"].default_value = (1.0, 1.0, 1.0, 1.0)  # White color
emission_node.inputs["Strength"].default_value = 10.0  # Adjust the strength as needed

# Link the emission node to the output node
# Connect the emission shader node to the output node
import bpy

# Get the default light
# Iterate through all lights in the scene
import bpy

# Create a new camera object
camera_data = bpy.data.cameras.new(name="Camera")
camera_object = bpy.data.objects.new(name="Camera", object_data=camera_data)

# Link the camera object to the scene
scene = bpy.context.scene
scene.collection.objects.link(camera_object)

# Set the camera's location and rotation
camera_object.location = (0, 0, 5)  # Adjust the coordinates as needed
camera_object.rotation_euler = (0, 0, 0)  # Adjust the rotation angles as needed

# Set the active camera in the scene
scene.camera = camera_object
import bpy

# Names of the objects to keep
objects_to_keep = ["MyCamera", "PointLight"]

# Iterate through all objects in the scene
for obj in bpy.data.objects:
    if obj.name not in objects_to_keep:
        bpy.data.objects.remove(obj, do_unlink=True)
import bpy

class CustomRenderEngine(bpy.types.RenderEngine):
    bl_idname = "Pixy"
    bl_label = "Pixy"

    def __init__(self):
        # Initialize your custom render engine
        pass
    
    def render(self, scene):
        # Render the scene using your custom engine
        pass

    def set_world_color(self, color):
        # Set the world color in your custom render engine
        pass

    def material_preview_mode(self):
        # Enable the material preview mode for your custom engine
        print("Rendered mode enabled")

# Register the custom render engine in Blender
bpy.utils.register_class(CustomRenderEngine)

# Set the render engine to your custom engine
bpy.context.scene.render.engine = 'Pixy'

# Define a callback function to update the world color
def update_world_color(scene, depsgraph):
    world_color = bpy.context.scene.world.custom_color
    custom_engine.set_world_color(world_color)

    # Add an extra indented block to trigger a redraw in the viewport
    for area in bpy.context.screen.areas:
        if area.type == 'VIEW_3D':
            area.tag_redraw()

# Add a color property to the World data
bpy.types.World.custom_color = bpy.props.FloatVectorProperty(
    name="Custom Color",
    subtype='COLOR',
    size=3,
    default=(1.0, 1.0, 1.0),
    min=0.0,
    max=1.0,
    update=update_world_color
)

# Define a function to enable material preview mode
def enable_material_preview_mode(depsgraph, scene):
    if bpy.context.scene.render.engine == 'Pixy':
        custom_engine.material_preview_mode()

# Register the function as a callback for the depsgraph_update_pre handler
bpy.app.handlers.depsgraph_update_pre.append(enable_material_preview_mode)

# Set the render engine to your custom engine
bpy.context.scene.render.engine = 'Pixy'
import bpy
import bgl
import blf
def setup_viewport():
    # Set viewport shading mode to Rendered
    bpy.context.space_data.shading.type = 'RENDERED'
def draw_callback_px(self, context):
    # Code to render your custom engine in the viewport
    # Use bgl and blf functions to draw directly to the viewport
    pass
def register_draw_handler():
    bpy.types.SpaceView3D.draw_handler_add(draw_callback_px, (None, None), 'WINDOW', 'POST_PIXEL')

def unregister_draw_handler():
    bpy.types.SpaceView3D.draw_handler_remove(draw_callback_px, 'WINDOW')
def start_custom_render_engine():
    # Additional setup for your custom render engine
    setup_viewport()
    register_draw_handler()

def stop_custom_render_engine():
    unregister_draw_handler()
    # Additional cleanup for your custom render engine
def invoke_custom_render_engine(self, context):
    start_custom_render_engine()
    # Additional logic specific to your custom render engine
    return {'FINISHED'}
import bpy

def set_material_preview_to_rendered_mode():
    # Set the viewport shading mode to RENDERED
    for area in bpy.context.screen.areas:
        if area.type == 'VIEW_3D':
            for space in area.spaces:
                if space.type == 'VIEW_3D':
                    space.shading.type = 'MATERIAL'
                    break

# Call the function to change the viewport mode
set_material_preview_to_rendered_mode()
import bpy

def draw_callback_px(self, context):
    # Your rendering logic goes here

    # Example: Clear the viewport
    bpy.context.window_manager.bars = True
    bpy.ops.wm.redraw_timer(type='DRAW_WIN_SWAP', iterations=1)

# Register the draw handler
args = (None, None)  # Additional arguments if needed
bpy.types.SpaceView3D.draw_handler_add(draw_callback_px, args, 'WINDOW', 'POST_VIEW')
import bpy

# Add a new object (example: cube)
bpy.ops.mesh.primitive_cube_add()

# Get the reference to the newly added object
new_object = bpy.context.active_object

# Set the name of the object to "Object"
new_object.name = "Object"
import bpy
# Trigger a redraw to update the viewport
bpy.ops.wm.redraw_timer(type='DRAW_WIN_SWAP', iterations=1)
import bpy

# Get the active object (assuming it's already selected)
obj = bpy.context.active_object

# Create a new material
mat = bpy.data.materials.new(name="MyMaterial")
obj.data.materials.append(mat)

# Set the diffuse color of the material
mat.diffuse_color = (1.0, 0.0, 0.0, 1.0)  # (R, G, B, Alpha)

# Set the specular color of the material
mat.specular_color = (0.5, 0.5, 0.5)

# Set the object to use the assigned material
obj.active_material = mat
import bpy

# Get the active 3D View area
area = next(area for area in bpy.context.screen.areas if area.type == 'VIEW_3D')

# Set the shading mode to Solid in the active 3D View area
for space in area.spaces:
    if space.type == 'VIEW_3D':
        space.shading.type = 'SOLID'

import bpy

# Create a new camera object
camera_data = bpy.data.cameras.new(name="MyCamera")
camera_object = bpy.data.objects.new(name="MyCamera", object_data=camera_data)

# Set the camera properties
camera_object.location = (0, 0, 5)  # Set the position of the camera
camera_object.rotation_euler = (0, 0, 0)  # Set the rotation of the camera

# Add the camera to the scene
scene = bpy.context.scene
scene.collection.objects.link(camera_object)

# Set the newly created camera as the active camera
scene.camera = camera_object
import bpy

# Set the desired render settings (optional)
bpy.context.scene.render.image_settings.file_format = 'PNG'
bpy.context.scene.render.filepath = '/path/to/save/render.png'

# Trigger the render operation
bpy.ops.render.render(write_still=True)
import bpy

# Set the render engine
bpy.context.scene.render.engine = 'Pixy'  # Use the Pixy render engine

# Set the render resolution
bpy.context.scene.render.resolution_x = 1920
bpy.context.scene.render.resolution_y = 1080

# Set the number of samples for rendering
bpy.context.scene.cycles.samples = 100

# Set the output file format and path
bpy.context.scene.render.image_settings.file_format = 'PNG'
bpy.context.scene.render.filepath = '/path/to/save/render.png'

# Set other render settings as needed
# ...

# Render the image
bpy.ops.render.render(write_still=True)
import bpy
from bpy.types import Panel

# Custom panel class for render settings
class RenderSettingsPanel(Panel):
    bl_idname = "RENDER_PT_custom_panel"
    bl_label = "Custom Render Settings"
    bl_space_type = 'PROPERTIES'
    bl_region_type = 'WINDOW'
    bl_context = "render"

    def draw(self, context):
        layout = self.layout
        scene = context.scene

        # Add a collapsible panel
        box = layout.box()
        box.label(text="Render Settings")
        
        # Add settings within the panel
        box.prop(scene.render, "resolution_x")
        box.prop(scene.render, "resolution_y")
        
        # Add a setting with limits
        box.prop(scene.render, "frame_start")
        box.prop(scene.render, "frame_end")
        box.prop(scene.render, "frame_step")

        # Example: Set limits for a numeric property
        box.prop(scene.render, "fps_base")
        box.prop(scene.render, "fps", text="FPS (Frames Per Second)", slider=True)

# Register the custom panel
def register():
    bpy.utils.register_class(RenderSettingsPanel)

# Unregister the custom panel
def unregister():
    bpy.utils.unregister_class(RenderSettingsPanel)

# Register the panel when running the script directly
if __name__ == "__main__":
    register()
import bpy
from bpy.types import Panel

# Custom panel class for output settings
class CustomOutputPanel(Panel):
    bl_idname = "OUTPUT_PT_custom_panel"
    bl_label = "Sample Settings"
    bl_space_type = 'PROPERTIES'
    bl_region_type = 'WINDOW'
    bl_context = "output"

    def draw(self, context):
        layout = self.layout
        scene = context.scene

        # Add panel contents
        layout.label(text="Sample Settings")
        layout.prop(scene.custom_output_settings, "sample_count")

# Register the custom panel
def register():
    bpy.utils.register_class(CustomOutputPanel)
    bpy.types.Scene.custom_output_settings = bpy.props.PointerProperty(type=CustomOutputSettings)

# Unregister the custom panel
def unregister():
    bpy.utils.unregister_class(CustomOutputPanel)
    del bpy.types.Scene.custom_output_settings

# Custom property group for output settings
class CustomOutputSettings(bpy.types.PropertyGroup):
    sample_count: bpy.props.IntProperty(
        name="Sample Count",
        description="Number of samples",
        default=16,
        min=1,
        max=256
    )

# Register the property group
def register():
    bpy.utils.register_class(CustomOutputPanel)
    bpy.utils.register_class(CustomOutputSettings)
    bpy.types.Scene.custom_output_settings = bpy.props.PointerProperty(type=CustomOutputSettings)

# Unregister the property group
def unregister():
    bpy.utils.unregister_class(CustomOutputPanel)
    bpy.utils.unregister_class(CustomOutputSettings)
    del bpy.types.Scene.custom_output_settings

# Register the panel and property group when running the script directly
if __name__ == "__main__":
    register()
import bpy


class CustomColorProperties(bpy.types.PropertyGroup):
    subsurface_scattering: bpy.props.FloatProperty(
        name="Subsurface Scattering",
        default=0.0,
        min=0.0,
        max=1.0
    )
    clearcoat_gloss: bpy.props.FloatProperty(
        name="Clearcoat Gloss",
        default=0.0,
        min=0.0,
        max=1.0
    )
    gloss: bpy.props.FloatProperty(
        name="Gloss",
        default=0.0,
        min=0.0,
        max=1.0
    )
    sheen: bpy.props.FloatProperty(
        name="Sheen",
        default=0.0,
        min=0.0,
        max=1.0
    )
    sheen_tint: bpy.props.FloatProperty(
        name="Sheen Tint",
        default=0.0,
        min=0.0,
        max=1.0
    )
    anisotropic: bpy.props.FloatProperty(
        name="Anisotropic",
        default=0.0,
        min=0.0,
        max=1.0
    )
    specular: bpy.props.FloatProperty(
        name="Specular",
        default=0.0,
        min=0.0,
        max=1.0
    )
    specular_tint: bpy.props.FloatProperty(
        name="Specular Tint",
        default=0.0,
        min=0.0,
        max=1.0
    )


class CustomColorPanel(bpy.types.Panel):
    bl_label = "Object Properties"
    bl_idname = "OBJECT_PT_object_properties"
    bl_space_type = 'PROPERTIES'
    bl_region_type = 'WINDOW'
    bl_context = "material"

    @classmethod
    def poll(cls, context):
        return context.object is not None and context.object.active_material is not None

    def draw(self, context):
        layout = self.layout
        material = context.object.active_material

        if material is not None:
            custom_color_props = material.custom_color_props

            # Subsurface Scattering
            layout.prop(custom_color_props, "subsurface_scattering")

            # Clearcoat Gloss
            layout.prop(custom_color_props, "clearcoat_gloss")

            # Gloss
            layout.prop(custom_color_props, "gloss")

            # Sheen
            layout.prop(custom_color_props, "sheen")

            # Sheen Tint
            layout.prop(custom_color_props, "sheen_tint")

            # Anisotropic
            layout.prop(custom_color_props, "anisotropic")

            # Specular
            layout.prop(custom_color_props, "specular")

            # Specular Tint
            layout.prop(custom_color_props, "specular_tint")


classes = (CustomColorPanel, CustomColorProperties)


def register():
    for cls in classes:
        bpy.utils.register_class(cls)
    bpy.types.Material.custom_color_props = bpy.props.PointerProperty(type=CustomColorProperties)


def unregister():
    for cls in classes:
        bpy.utils.unregister_class(cls)
    del bpy.types.Material.custom_color_props


if __name__ == "__main__":
    register()
import bpy
from bpy.props import BoolProperty
from bpy.types import Panel, Operator

# Custom Shader Node
class CustomShaderNode(bpy.types.ShaderNodeCustomGroup):
    bl_label = "Custom Shader"
    bl_idname = "CUSTOM_SHADER_NODE"

    # Define the node's inputs and outputs
    def init(self, context):
        self.inputs.new("NodeSocketColor", "Color")
        self.outputs.new("NodeSocketColor", "Output")

    # Implement the shader logic
    def update(self):
        # Perform custom shader calculations here
        pass

# Custom Render Mode Panel
class CustomRenderModePanel(bpy.types.Panel):
    bl_label = "Custom Render Mode"
    bl_idname = "VIEW3D_PT_custom_render_mode"
    bl_space_type = 'VIEW_3D'
    bl_region_type = 'UI'
    bl_category = "Custom"

    def draw(self, context):
        layout = self.layout
        layout.operator("custom.set_render_mode", text="Enable Custom Render Mode")
        layout.operator("custom.reset_render_mode", text="Disable Custom Render Mode")

# Enable Custom Render Mode Operator
class EnableCustomRenderModeOperator(Operator):
    bl_idname = "custom.set_render_mode"
    bl_label = "Enable Custom Render Mode"

    def execute(self, context):
        context.space_data.shading.type = 'RENDERED'
        return {'FINISHED'}

# Disable Custom Render Mode Operator
class DisableCustomRenderModeOperator(Operator):
    bl_idname = "custom.reset_render_mode"
    bl_label = "Disable Custom Render Mode"

    def execute(self, context):
        context.space_data.shading.type = 'SOLID'
        return {'FINISHED'}

# Register the custom classes
def register():
    bpy.utils.register_class(CustomShaderNode)
    bpy.utils.register_class(CustomRenderModePanel)
    bpy.utils.register_class(EnableCustomRenderModeOperator)
    bpy.utils.register_class(DisableCustomRenderModeOperator)

def unregister():
    bpy.utils.unregister_class(CustomShaderNode)
    bpy.utils.unregister_class(CustomRenderModePanel)
    bpy.utils.unregister_class(EnableCustomRenderModeOperator)
    bpy.utils.unregister_class(DisableCustomRenderModeOperator)

# Entry point to register the custom classes
if __name__ == "__main__":
    register()
import bpy
from bpy.types import Panel, Operator

# Custom Render Mode Operator
class CustomRenderModeOperator(Operator):
    bl_idname = "view3d.custom_render_mode"
    bl_label = "Custom Render Mode"

    def execute(self, context):
        # Implement the logic for your custom render mode here
        return {'FINISHED'}

# Custom Render Mode Panel
class CustomRenderModePanel(Panel):
    bl_label = "Custom Render Mode"
    bl_idname = "VIEW3D_PT_custom_render_mode"
    bl_space_type = 'VIEW_3D'
    bl_region_type = 'UI'
    bl_category = "Custom"

    def draw(self, context):
        layout = self.layout
        layout.operator("view3d.custom_render_mode", text="Enable Custom Render Mode")

# Register the custom classes
def register():
    bpy.utils.register_class(CustomRenderModeOperator)
    bpy.utils.register_class(CustomRenderModePanel)

def unregister():
    bpy.utils.unregister_class(CustomRenderModeOperator)
    bpy.utils.unregister_class(CustomRenderModePanel)

# Entry point to register the custom classes
if __name__ == "__main__":
    register()
import bpy

# Get the value of the custom render property from the active object
property1 = bpy.context.object.get("property1")

# Create a Point Light
point_light = bpy.data.lights.new(name="PointLight", type='POINT')
point_light.energy = 100.0  # Set the light intensity

# Create a light object and link it to the scene
point_light_object = bpy.data.objects.new(name="PointLight", object_data=point_light)
bpy.context.collection.objects.link(point_light_object)
bpy.context.view_layer.objects.active = point_light_object

# Enable or disable the light object based on the viewport shading mode
if bpy.context.active_object.mode == 'OBJECT':
    shading_type = bpy.context.active_object.show_instancer_for_render
    if shading_type == 'RENDER':
        if property1:
            point_light_object.hide_viewport = False
        else:
            point_light_object.hide_viewport = True
    else:
        point_light_object.hide_viewport = True
else:
    point_light_object.hide_viewport = True
import bpy


class LightPropertiesPanel(bpy.types.Panel):
    bl_label = "Light Properties"
    bl_idname = "OBJECT_PT_light_properties"
    bl_space_type = 'PROPERTIES'
    bl_region_type = 'WINDOW'
    bl_context = "data"
    bl_option = {'DEFAULT_CLOSED'}

    @classmethod
    def poll(cls, context):
        return context.light is not None

    def draw(self, context):
        layout = self.layout
        light = context.light

        layout.use_property_split = True
        layout.use_property_decorate = False

        row = layout.row()
        row.prop(light, "energy")

        row = layout.row()
        row.prop(light, "color")


def register():
    bpy.utils.register_class(LightPropertiesPanel)


def unregister():
    bpy.utils.unregister_class(LightPropertiesPanel)


if __name__ == "__main__":
    register()
